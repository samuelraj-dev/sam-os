// #include "font8x8_basic.h"
#include "display.h"
#include "bootinfo.h"
#include "gdt.h"
#include "tss.h"
#include "idt.h"
#include "pic.h"
#include "timer.h"
#include "keyboard.h"
#include "paging.h"
#include "pmm.h"
#include "types.h"

// ── Higher-half offset ───────────────────────────────────────────────────────
// The bootloader loaded us at physical 0x100000 but we are linked at
// 0xFFFFFFFF80100000.  Any physical pointer passed in from the bootloader
// (framebuffer, memory_map) must be offset by this value to become a valid
// virtual address once our own page tables are in place.
// For now we keep using physical addresses directly because the bootstrap
// and kernel page tables both identity-map all physical RAM, so physical ==
// virtual for the low 4 GB region.  We leave a helper macro here for when
// you add a proper direct-physical-map in the VMM.
#define PHYS_TO_VIRT(p)  (p)   // identity-mapped for now; update when VMM adds offset

static uint32_t* fb;
static uint32_t  screen_w, screen_h, pitch;
static uint32_t  cursor_x = 0;
static uint32_t  cursor_y = 0;
static uint32_t  fg_color = 0x00FFFFFF;
static uint32_t  bg_color = 0x00303030;

// ── Basic I/O ports ──────────────────────────────────────────────────────────
static inline uint8_t inb(uint16_t port) {
    uint8_t v;
    __asm__ volatile ("inb %1, %0" : "=a"(v) : "Nd"(port));
    return v;
}

static inline void outb(uint16_t port, uint8_t value) {
    __asm__ volatile ("outb %0, %1" :: "a"(value), "Nd"(port));
}

// ── CMOS / RTC ───────────────────────────────────────────────────────────────
uint8_t cmos_read(uint8_t reg) {
    outb(0x70, reg);
    return inb(0x71);
}

uint8_t bcd_to_bin(uint8_t val) {
    return (val & 0x0F) + ((val >> 4) * 10);
}

void print_time(void) {
    uint8_t sec   = bcd_to_bin(cmos_read(0x00));
    uint8_t min   = bcd_to_bin(cmos_read(0x02));
    uint8_t hour  = bcd_to_bin(cmos_read(0x04));
    uint8_t day   = bcd_to_bin(cmos_read(0x07));
    uint8_t month = bcd_to_bin(cmos_read(0x08));
    uint8_t year  = bcd_to_bin(cmos_read(0x09));

    print("Date: ");
    print_dec(day);   print("/");
    print_dec(month); print("/");
    print_dec(2000 + year);
    print("\nTime: ");
    print_dec(hour); print(":");
    print_dec(min);  print(":");
    print_dec(sec);
    print("\n");
}

// ── CPUID ────────────────────────────────────────────────────────────────────
void cpuid(uint32_t leaf, uint32_t* a, uint32_t* b, uint32_t* c, uint32_t* d) {
    __asm__ volatile ("cpuid"
        : "=a"(*a), "=b"(*b), "=c"(*c), "=d"(*d)
        : "a"(leaf));
}

void print_cpu_info(void) {
    uint32_t a, b, c, d;
    char vendor[13];

    cpuid(0, &a, &b, &c, &d);
    *((uint32_t*)&vendor[0]) = b;
    *((uint32_t*)&vendor[4]) = d;
    *((uint32_t*)&vendor[8]) = c;
    vendor[12] = 0;
    print("CPU Vendor: "); print(vendor); print("\n");

    char brand[49];
    for (int i = 0; i < 3; i++) {
        cpuid(0x80000002 + i, &a, &b, &c, &d);
        *((uint32_t*)&brand[i*16 +  0]) = a;
        *((uint32_t*)&brand[i*16 +  4]) = b;
        *((uint32_t*)&brand[i*16 +  8]) = c;
        *((uint32_t*)&brand[i*16 + 12]) = d;
    }
    brand[48] = 0;
    print("CPU: "); print(brand); print("\n");
}

// ── Memory map helpers ───────────────────────────────────────────────────────
void print_memory_map(BootInfo* bootInfo) {
    print("Memory Map Entries:\n");
    uint8_t* mmap = (uint8_t*)bootInfo->memory_map;

    for (uint64_t off = 0; off < bootInfo->memory_map_size;
         off += bootInfo->memory_map_descriptor_size) {
        uint64_t type  = *(uint32_t*)(mmap + off);
        uint64_t phys  = *(uint64_t*)(mmap + off +  8);
        uint64_t pages = *(uint64_t*)(mmap + off + 16);
        print("Type "); print_dec(type);
        print(" | Addr "); print_hex(phys);
        print(" | Pages "); print_dec(pages);
        print("\n");
    }
}

void print_total_ram(BootInfo* bootInfo) {
    uint8_t*  mmap        = (uint8_t*)bootInfo->memory_map;
    uint64_t  total_bytes = 0;

    for (uint64_t off = 0; off < bootInfo->memory_map_size;
         off += bootInfo->memory_map_descriptor_size) {
        EFI_MEMORY_DESCRIPTOR* desc = (EFI_MEMORY_DESCRIPTOR*)(mmap + off);
        if (desc->Type == 7)   // EfiConventionalMemory
            total_bytes += desc->NumberOfPages * 4096ULL;
    }

    print("Usable RAM: ");
    print_dec(total_bytes / (1024 * 1024));
    print(" MB\n");
}

static void delay(void) {
    for (volatile int i = 0; i < 10000000; i++);
}

// ── kernel_main ──────────────────────────────────────────────────────────────
void kernel_main(BootInfo* bootInfo)
{
    // ── Display init ─────────────────────────────────────────────────────────
    // bootInfo->framebuffer is a physical address (e.g. 0x80000000 in QEMU).
    // The bootstrap page tables identity-map all physical RAM including the
    // framebuffer region, so we can use it directly as a virtual address.
    display_init(
        (uint32_t*)bootInfo->framebuffer,
        bootInfo->width,
        bootInfo->height,
        bootInfo->pixels_per_scanline
    );

    fb       = (uint32_t*)bootInfo->framebuffer;
    screen_w = bootInfo->width;
    screen_h = bootInfo->height;
    pitch    = bootInfo->pixels_per_scanline;

    // Clear screen to dark grey
    uint32_t* real_fb = (uint32_t*)bootInfo->framebuffer;
    for (uint32_t y = 0; y < bootInfo->height; y++)
        for (uint32_t x = 0; x < bootInfo->pixels_per_scanline; x++)
            real_fb[y * bootInfo->pixels_per_scanline + x] = 0x00303030;

    print("SamOS Kernel\n\n");

    // ── Basic info ───────────────────────────────────────────────────────────
    print_total_ram(bootInfo);
    print("\n");

    print("Memory map size: ");
    print_dec(bootInfo->memory_map_size);
    print("\n");

    print("Descriptor size: ");
    print_dec(bootInfo->memory_map_descriptor_size);
    print("\n\n");

    print("Framebuffer: ");
    print_hex((uint64_t)bootInfo->framebuffer);
    print("\n\n");

    print("kernel start: ");
    print_hex((uint64_t)&_kernel_start);
    print("\n");

    print("kernel end: ");
    print_hex((uint64_t)&_kernel_end);
    print("\n\n");

    // ── Core CPU structures ──────────────────────────────────────────────────
    gdt_init();
    print("Initialized Global Descriptor Table (GDT).\n");
    tss_init();
    print("Initialized Task State Segment (TSS).\n");
    idt_init();
    print("Initialized Interrupt Descriptor Table (IDT).\n");
    pic_init();
    print("Initialized Programmable Interrupt Controller (PIC).\n");

    // timer_init(100);
    keyboard_init();



    // pic_unmask(0); // timer
    pic_unmask(1); // keyboard

    __asm__ volatile ("sti");
    print("Interrupts enabled.\n\n");

    // ── Paging ───────────────────────────────────────────────────────────────
    // paging_init() builds proper kernel page tables and switches CR3.
    // It MUST map:
    //   1. identity 0..max_physical  (so physical ptrs still work)
    //   2. higher half 0xFFFFFFFF80000000 → phys 0 (so kernel code keeps running)
    //   3. the framebuffer region    (so display keeps working after CR3 switch)
    paging_init(bootInfo);
    print("Paging switched successfully.\n\n");
    delay();

    // ── Physical Memory Manager ──────────────────────────────────────────────
    pmm_init(bootInfo);
    delay();
    print("Initialized Physical Memory Manager (PMM).\n\n");
    delay();
    // while(1) __asm__ volatile("hlt"); 

    // ── Shadow framebuffer ───────────────────────────────────────────────────
    uint32_t fb_bytes = screen_h * pitch * 4;
    print("fb_bytes: "); print_dec(fb_bytes); print("\n");

    uint32_t fb_pages = (fb_bytes + 4095) / 4096;
    print("fb_pages: "); print_dec(fb_pages); print("\n");

    uint32_t* shadow = (uint32_t*)pmm_alloc_pages(fb_pages);
    print("shadow: "); print_hex((uint64_t)shadow); print("\n");

    display_set_shadow(shadow);

    // Copy current framebuffer into shadow so existing text is preserved
    uint64_t total = (uint64_t)screen_h * pitch;
    // uint32_t* real_fb = (uint32_t*)bootInfo->framebuffer;
    for (uint64_t i = 0; i < total; i++)
        shadow[i] = real_fb[i];

    // Now shadow matches fb — no visual change on flush
    display_flush();
    print("SamOS ready — type something:\n");
    // while(1) __asm__ volatile("hlt"); 

    // ── Main loop ────────────────────────────────────────────────────────────
    uint64_t last = 0;
    while (1) {
        __asm__ volatile ("hlt");

        // Poll keyboard
        if (inb(0x64) & 0x01) {
            uint8_t sc = inb(0x60);
            if (sc == 0x00 || sc == 0xAA || sc == 0xFA) continue;
            if (!(sc & 0x80) && sc < 128 && scancode_map[sc]) {
                char str[2] = { scancode_map[sc], 0 };
                print(str);
            }
        }

        if (timer_flush_needed()) display_flush();

        uint64_t t = timer_get_ticks();
        if (t >= last + 100) {
            last = t;
            print("tick: ");
            print_dec(t);
            print("\n");
        }
    }
}