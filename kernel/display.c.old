#include "display.h"
#include "font8x8_basic.h"

static uint32_t* sb = 0;   // shadow buffer (physical addr, identity-mapped)
static uint32_t* fb = 0;   // real framebuffer (physical addr, identity-mapped)
static uint32_t  screen_w = 0;
static uint32_t  screen_h = 0;
static uint32_t  pitch    = 0;
static uint32_t  cursor_x = 0;
static uint32_t  cursor_y = 0;
static uint32_t  fg_color = 0x00FFFFFF;
static uint32_t  bg_color = 0x00303030;


// ── Public API ───────────────────────────────────────────────────────────────

void display_init(uint32_t* framebuffer, uint32_t width,
                  uint32_t height, uint32_t pixels_per_scanline)
{
    fb       = framebuffer;
    screen_w = width;
    screen_h = height;
    pitch    = pixels_per_scanline;
    cursor_x = 0;
    cursor_y = 0;
}

void display_set_shadow(uint32_t* buffer)
{
    sb = buffer;
}

uint32_t display_get_height(void) { return screen_h; }
uint32_t display_get_pitch(void)  { return pitch;    }

// ── Flush shadow → real framebuffer ─────────────────────────────────────────
// All sizes cast to uint64_t to avoid uint32_t overflow on large resolutions.

void display_flush(void)
{
    if (!sb || !fb) return;

    for (uint32_t y = 0; y < screen_h; y++)
        for (uint32_t x = 0; x < pitch; x++)
            fb[y * pitch + x] = sb[y * pitch + x];
}

// in display.c — temporary debug
void display_flush_debug(void)
{
    print("screen_h: "); print_dec(screen_h); print("\n");
    print("pitch: ");    print_dec(pitch);    print("\n");
    print("fb: ");       print_hex((uint64_t)fb); print("\n");
    print("sb: ");       print_hex((uint64_t)sb); print("\n");
    display_flush();
}

// ── Internal helpers ─────────────────────────────────────────────────────────

static void put_pixel(uint32_t x, uint32_t y, uint32_t color)
{
    if (sb) sb[y * pitch + x] = color;
    else if (fb) fb[y * pitch + x] = color;
}

static void scroll(void)
{
    if (!sb) return;

    const uint32_t SCROLL_LINES = 10;

    uint64_t row_bytes  = (uint64_t)pitch * 4;
    uint64_t copy_bytes = (uint64_t)(screen_h - SCROLL_LINES) * row_bytes;

    uint8_t* src = (uint8_t*)sb + (uint64_t)SCROLL_LINES * row_bytes;
    uint8_t* dst = (uint8_t*)sb;

    uint64_t* s64 = (uint64_t*)src;
    uint64_t* d64 = (uint64_t*)dst;
    for (uint64_t i = 0; i < copy_bytes / 8; i++)
        d64[i] = s64[i];

    for (uint32_t y = screen_h - SCROLL_LINES; y < screen_h; y++)
        for (uint32_t x = 0; x < screen_w; x++)
            sb[y * pitch + x] = bg_color;

    // Guard against underflow
    if (cursor_y >= SCROLL_LINES)
        cursor_y -= SCROLL_LINES;
    else
        cursor_y = 0;
}

// ── Character rendering ──────────────────────────────────────────────────────

static void draw_char(char c, uint32_t x, uint32_t y)
{
    unsigned char* glyph = font8x8_basic[(uint8_t)c];

    for (int row = 0; row < 8; row++) {
        for (int col = 0; col < 8; col++) {
            uint32_t color = (glyph[row] & (1 << col)) ? fg_color : bg_color;
            put_pixel(x + col, y + row, color);
        }
    }
}

void print_char(char c)
{
    if (!screen_w || !screen_h || !sb) return;

    if (c == '\n') {
        cursor_x = 0;
        cursor_y += 10;
        if (cursor_y + 10 >= screen_h) scroll();
        return;
    }

    if (cursor_x + 8 > screen_w) {
        cursor_x = 0;
        cursor_y += 10;
        if (cursor_y + 10 >= screen_h) scroll();
    }

    // Final bounds check before drawing
    if (cursor_y + 8 > screen_h) return;

    draw_char(c, cursor_x, cursor_y);
    cursor_x += 8;

    if (cursor_x + 8 >= screen_w) {
        cursor_x = 0;
        cursor_y += 10;
        if (cursor_y + 10 >= screen_h) scroll();
    }
}

// ── Print functions ──────────────────────────────────────────────────────────

void print(const char* str)
{
    while (*str)
        print_char(*str++);
}

void print_hex(uint64_t val)
{
    const char hex[] = "0123456789ABCDEF";
    print("0x");
    for (int i = 60; i >= 0; i -= 4)
        print_char(hex[(val >> i) & 0xF]);
}

void print_dec(uint64_t val)
{
    if (val == 0) { print_char('0'); return; }

    char buf[32];
    int  i = 0;

    while (val > 0) {
        buf[i++] = '0' + (val % 10);
        val /= 10;
    }

    for (int j = i - 1; j >= 0; j--)
        print_char(buf[j]);
}

void clear_screen(void)
{
    if (!fb) return;
    for (uint32_t y = 0; y < screen_h; y++)
        for (uint32_t x = 0; x < screen_w; x++)
            fb[y * pitch + x] = bg_color;
}